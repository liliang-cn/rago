package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"

	"github.com/spf13/cobra"
)

var (
	initDir string
)

var initCmd = &cobra.Command{
	Use:   "init",
	Short: "Initialize RAGO working directory",
	Long: `Initialize RAGO working directory with necessary files and directories.

This command creates:
  - The working directory (default: ~/.rago/)
  - data/ subdirectory for databases
  - .skills/ subdirectory for custom skills
  - .intents/ subdirectory for intent definitions
  - workspace/ subdirectory for working files
  - rago.toml configuration file
  - mcpServers.json for MCP server configurations

If a file or directory already exists, it will be skipped (not overwritten).`,
	RunE: runInit,
}

func init() {
	RootCmd.AddCommand(initCmd)
	initCmd.Flags().StringVarP(&initDir, "dir", "d", "", "Working directory (default: ~/.rago/)")
}

func runInit(cmd *cobra.Command, args []string) error {
	// Determine the working directory
	workDir := initDir
	if workDir == "" {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get home directory: %w", err)
		}
		workDir = filepath.Join(homeDir, ".rago")
	}

	// Expand ~ if present
	if workDir[0] == '~' {
		homeDir, err := os.UserHomeDir()
		if err != nil {
			return fmt.Errorf("failed to get home directory: %w", err)
		}
		workDir = filepath.Join(homeDir, workDir[1:])
	}

	// Normalize the path
	workDir = filepath.Clean(workDir)

	fmt.Printf("ðŸš€ Initializing RAGO in: %s\n\n", workDir)

	// Create working directory
	if err := createDirIfNotExists(workDir); err != nil {
		return fmt.Errorf("failed to create working directory: %w", err)
	}

	// Create data directory
	dataDir := filepath.Join(workDir, "data")
	if err := createDirIfNotExists(dataDir); err != nil {
		return fmt.Errorf("failed to create data directory: %w", err)
	}

	// Create .skills directory
	skillsDir := filepath.Join(workDir, ".skills")
	if err := createDirIfNotExists(skillsDir); err != nil {
		return fmt.Errorf("failed to create .skills directory: %w", err)
	}

	// Create .intents directory
	intentsDir := filepath.Join(workDir, ".intents")
	if err := createDirIfNotExists(intentsDir); err != nil {
		return fmt.Errorf("failed to create .intents directory: %w", err)
	}

	// Create workspace directory
	workspaceDir := filepath.Join(workDir, "workspace")
	if err := createDirIfNotExists(workspaceDir); err != nil {
		return fmt.Errorf("failed to create workspace directory: %w", err)
	}

	// Create default rago.toml
	configFile := filepath.Join(workDir, "rago.toml")
	if err := createConfigFileIfNotExists(configFile); err != nil {
		return fmt.Errorf("failed to create config file: %w", err)
	}

	// Create default mcpServers.json
	mcpFile := filepath.Join(workDir, "mcpServers.json")
	if err := createMCPServersFileIfNotExists(mcpFile); err != nil {
		return fmt.Errorf("failed to create MCP servers file: %w", err)
	}

	fmt.Println("\nâœ… RAGO initialized successfully!")
	fmt.Printf("\nNext steps:\n")
	fmt.Printf("  1. Review and edit %s if needed\n", configFile)
	fmt.Printf("  2. Add MCP servers: rago mcp add <name> <command> [args...]\n")
	fmt.Printf("  3. Ingest documents: rago ingest <file-or-directory>\n")
	fmt.Printf("  4. Query: rago query <your-question>\n")

	return nil
}

func createDirIfNotExists(path string) error {
	info, err := os.Stat(path)
	if err == nil {
		if info.IsDir() {
			fmt.Printf("âœ“ Directory exists: %s\n", path)
			return nil
		}
		return fmt.Errorf("path exists but is not a directory: %s", path)
	}

	if os.IsNotExist(err) {
		if err := os.MkdirAll(path, 0755); err != nil {
			return fmt.Errorf("failed to create directory: %w", err)
		}
		fmt.Printf("âœ“ Created directory: %s\n", path)
		return nil
	}

	return err
}

func createConfigFileIfNotExists(path string) error {
	info, err := os.Stat(path)
	if err == nil {
		if !info.IsDir() {
			fmt.Printf("âœ“ Config file exists: %s\n", path)
			return nil
		}
		return fmt.Errorf("path exists but is a directory: %s", path)
	}

	if os.IsNotExist(err) {
		configContent := `# RAGO (Retrieval-Augmented Generation Offline) Configuration
# This file was auto-generated by 'rago init'

[llm_pool]
enabled = true
strategy = "round_robin"

[[llm_pool.providers]]
name = "ollama"
base_url = "http://localhost:11434/v1"
key = ""
model_name = "qwen3:8b"                # Change to your preferred model
max_concurrency = 5
capability = 4

[embedding_pool]
enabled = false
strategy = "round_robin"

[[embedding_pool.providers]]
name = "ollama-embedding"
base_url = "http://localhost:11434/v1"
key = ""
model_name = "qwen3-embedding:8b"      # Change to your preferred embedding model
max_concurrency = 10
capability = 4

[sqvect]
top_k = 5
threshold = 0.5
index_type = "flat"

[chunker]
chunk_size = 500
overlap = 50
method = "sentence"

[ingest]
[ingest.metadata_extraction]
enable = false

[mcp]
enabled = true
log_level = "info"
default_timeout = "5m"
max_concurrent_requests = 10
health_check_interval = "60s"
# Servers config is auto-detected at ~/.rago/mcpServers.json
`

		if err := os.WriteFile(path, []byte(configContent), 0644); err != nil {
			return fmt.Errorf("failed to write config file: %w", err)
		}
		fmt.Printf("âœ“ Created config file: %s\n", path)
		return nil
	}

	return err
}

func createMCPServersFileIfNotExists(path string) error {
	info, err := os.Stat(path)
	if err == nil {
		if !info.IsDir() {
			fmt.Printf("âœ“ MCP servers file exists: %s\n", path)
			return nil
		}
		return fmt.Errorf("path exists but is a directory: %s", path)
	}

	if os.IsNotExist(err) {
		// Create empty mcpServers.json
		mcpContent := map[string]interface{}{
			"mcpServers": map[string]interface{}{},
		}

		data, err := json.MarshalIndent(mcpContent, "", "  ")
		if err != nil {
			return fmt.Errorf("failed to marshal MCP config: %w", err)
		}

		if err := os.WriteFile(path, data, 0644); err != nil {
			return fmt.Errorf("failed to write MCP servers file: %w", err)
		}
		fmt.Printf("âœ“ Created MCP servers file: %s\n", path)
		return nil
	}

	return err
}
